// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/ch3nnn/webstack-go/internal/repository/mysql/model"
)

func newCronTask(db *gorm.DB, opts ...gen.DOOption) cronTask {
	_cronTask := cronTask{}

	_cronTask.cronTaskDo.UseDB(db, opts...)
	_cronTask.cronTaskDo.UseModel(&model.CronTask{})

	tableName := _cronTask.cronTaskDo.TableName()
	_cronTask.ALL = field.NewAsterisk(tableName)
	_cronTask.ID = field.NewInt64(tableName, "id")
	_cronTask.Name = field.NewString(tableName, "name")
	_cronTask.Spec = field.NewString(tableName, "spec")
	_cronTask.Command = field.NewString(tableName, "command")
	_cronTask.Protocol = field.NewInt64(tableName, "protocol")
	_cronTask.HTTPMethod = field.NewInt64(tableName, "http_method")
	_cronTask.Timeout = field.NewInt64(tableName, "timeout")
	_cronTask.RetryTimes = field.NewInt64(tableName, "retry_times")
	_cronTask.RetryInterval = field.NewInt64(tableName, "retry_interval")
	_cronTask.NotifyStatus = field.NewInt64(tableName, "notify_status")
	_cronTask.NotifyType = field.NewInt64(tableName, "notify_type")
	_cronTask.NotifyReceiverEmail = field.NewString(tableName, "notify_receiver_email")
	_cronTask.NotifyKeyword = field.NewString(tableName, "notify_keyword")
	_cronTask.Remark = field.NewString(tableName, "remark")
	_cronTask.IsUsed = field.NewInt64(tableName, "is_used")
	_cronTask.CreatedAt = field.NewTime(tableName, "created_at")
	_cronTask.CreatedUser = field.NewString(tableName, "created_user")
	_cronTask.UpdatedAt = field.NewTime(tableName, "updated_at")
	_cronTask.UpdatedUser = field.NewString(tableName, "updated_user")

	_cronTask.fillFieldMap()

	return _cronTask
}

type cronTask struct {
	cronTaskDo

	ALL                 field.Asterisk
	ID                  field.Int64  // 主键
	Name                field.String // 任务名称
	Spec                field.String // crontab 表达式
	Command             field.String // 执行命令
	Protocol            field.Int64  // 执行方式 1:shell 2:http
	HTTPMethod          field.Int64  // http 请求方式 1:get 2:post
	Timeout             field.Int64  // 超时时间(单位:秒)
	RetryTimes          field.Int64  // 重试次数
	RetryInterval       field.Int64  // 重试间隔(单位:秒)
	NotifyStatus        field.Int64  // 执行结束是否通知 1:不通知 2:失败通知 3:结束通知 4:结果关键字匹配通知
	NotifyType          field.Int64  // 通知类型 1:邮件 2:webhook
	NotifyReceiverEmail field.String // 通知者邮箱地址(多个用,分割)
	NotifyKeyword       field.String // 通知匹配关键字(多个用,分割)
	Remark              field.String // 备注
	IsUsed              field.Int64  // 是否启用 1:是  -1:否
	CreatedAt           field.Time   // 创建时间
	CreatedUser         field.String // 创建人
	UpdatedAt           field.Time   // 更新时间
	UpdatedUser         field.String // 更新人

	fieldMap map[string]field.Expr
}

func (c cronTask) Table(newTableName string) *cronTask {
	c.cronTaskDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c cronTask) As(alias string) *cronTask {
	c.cronTaskDo.DO = *(c.cronTaskDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *cronTask) updateTableName(table string) *cronTask {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewInt64(table, "id")
	c.Name = field.NewString(table, "name")
	c.Spec = field.NewString(table, "spec")
	c.Command = field.NewString(table, "command")
	c.Protocol = field.NewInt64(table, "protocol")
	c.HTTPMethod = field.NewInt64(table, "http_method")
	c.Timeout = field.NewInt64(table, "timeout")
	c.RetryTimes = field.NewInt64(table, "retry_times")
	c.RetryInterval = field.NewInt64(table, "retry_interval")
	c.NotifyStatus = field.NewInt64(table, "notify_status")
	c.NotifyType = field.NewInt64(table, "notify_type")
	c.NotifyReceiverEmail = field.NewString(table, "notify_receiver_email")
	c.NotifyKeyword = field.NewString(table, "notify_keyword")
	c.Remark = field.NewString(table, "remark")
	c.IsUsed = field.NewInt64(table, "is_used")
	c.CreatedAt = field.NewTime(table, "created_at")
	c.CreatedUser = field.NewString(table, "created_user")
	c.UpdatedAt = field.NewTime(table, "updated_at")
	c.UpdatedUser = field.NewString(table, "updated_user")

	c.fillFieldMap()

	return c
}

func (c *cronTask) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *cronTask) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 19)
	c.fieldMap["id"] = c.ID
	c.fieldMap["name"] = c.Name
	c.fieldMap["spec"] = c.Spec
	c.fieldMap["command"] = c.Command
	c.fieldMap["protocol"] = c.Protocol
	c.fieldMap["http_method"] = c.HTTPMethod
	c.fieldMap["timeout"] = c.Timeout
	c.fieldMap["retry_times"] = c.RetryTimes
	c.fieldMap["retry_interval"] = c.RetryInterval
	c.fieldMap["notify_status"] = c.NotifyStatus
	c.fieldMap["notify_type"] = c.NotifyType
	c.fieldMap["notify_receiver_email"] = c.NotifyReceiverEmail
	c.fieldMap["notify_keyword"] = c.NotifyKeyword
	c.fieldMap["remark"] = c.Remark
	c.fieldMap["is_used"] = c.IsUsed
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["created_user"] = c.CreatedUser
	c.fieldMap["updated_at"] = c.UpdatedAt
	c.fieldMap["updated_user"] = c.UpdatedUser
}

func (c cronTask) clone(db *gorm.DB) cronTask {
	c.cronTaskDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c cronTask) replaceDB(db *gorm.DB) cronTask {
	c.cronTaskDo.ReplaceDB(db)
	return c
}

type cronTaskDo struct{ gen.DO }

type ICronTaskDo interface {
	gen.SubQuery
	Debug() ICronTaskDo
	WithContext(ctx context.Context) ICronTaskDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICronTaskDo
	WriteDB() ICronTaskDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICronTaskDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICronTaskDo
	Not(conds ...gen.Condition) ICronTaskDo
	Or(conds ...gen.Condition) ICronTaskDo
	Select(conds ...field.Expr) ICronTaskDo
	Where(conds ...gen.Condition) ICronTaskDo
	Order(conds ...field.Expr) ICronTaskDo
	Distinct(cols ...field.Expr) ICronTaskDo
	Omit(cols ...field.Expr) ICronTaskDo
	Join(table schema.Tabler, on ...field.Expr) ICronTaskDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICronTaskDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICronTaskDo
	Group(cols ...field.Expr) ICronTaskDo
	Having(conds ...gen.Condition) ICronTaskDo
	Limit(limit int) ICronTaskDo
	Offset(offset int) ICronTaskDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICronTaskDo
	Unscoped() ICronTaskDo
	Create(values ...*model.CronTask) error
	CreateInBatches(values []*model.CronTask, batchSize int) error
	Save(values ...*model.CronTask) error
	First() (*model.CronTask, error)
	Take() (*model.CronTask, error)
	Last() (*model.CronTask, error)
	Find() ([]*model.CronTask, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CronTask, err error)
	FindInBatches(result *[]*model.CronTask, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.CronTask) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICronTaskDo
	Assign(attrs ...field.AssignExpr) ICronTaskDo
	Joins(fields ...field.RelationField) ICronTaskDo
	Preload(fields ...field.RelationField) ICronTaskDo
	FirstOrInit() (*model.CronTask, error)
	FirstOrCreate() (*model.CronTask, error)
	FindByPage(offset int, limit int) (result []*model.CronTask, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICronTaskDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c cronTaskDo) Debug() ICronTaskDo {
	return c.withDO(c.DO.Debug())
}

func (c cronTaskDo) WithContext(ctx context.Context) ICronTaskDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c cronTaskDo) ReadDB() ICronTaskDo {
	return c.Clauses(dbresolver.Read)
}

func (c cronTaskDo) WriteDB() ICronTaskDo {
	return c.Clauses(dbresolver.Write)
}

func (c cronTaskDo) Session(config *gorm.Session) ICronTaskDo {
	return c.withDO(c.DO.Session(config))
}

func (c cronTaskDo) Clauses(conds ...clause.Expression) ICronTaskDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c cronTaskDo) Returning(value interface{}, columns ...string) ICronTaskDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c cronTaskDo) Not(conds ...gen.Condition) ICronTaskDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c cronTaskDo) Or(conds ...gen.Condition) ICronTaskDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c cronTaskDo) Select(conds ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c cronTaskDo) Where(conds ...gen.Condition) ICronTaskDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c cronTaskDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ICronTaskDo {
	return c.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (c cronTaskDo) Order(conds ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c cronTaskDo) Distinct(cols ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c cronTaskDo) Omit(cols ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c cronTaskDo) Join(table schema.Tabler, on ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c cronTaskDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c cronTaskDo) RightJoin(table schema.Tabler, on ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c cronTaskDo) Group(cols ...field.Expr) ICronTaskDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c cronTaskDo) Having(conds ...gen.Condition) ICronTaskDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c cronTaskDo) Limit(limit int) ICronTaskDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c cronTaskDo) Offset(offset int) ICronTaskDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c cronTaskDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICronTaskDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c cronTaskDo) Unscoped() ICronTaskDo {
	return c.withDO(c.DO.Unscoped())
}

func (c cronTaskDo) Create(values ...*model.CronTask) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c cronTaskDo) CreateInBatches(values []*model.CronTask, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c cronTaskDo) Save(values ...*model.CronTask) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c cronTaskDo) First() (*model.CronTask, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.CronTask), nil
	}
}

func (c cronTaskDo) Take() (*model.CronTask, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.CronTask), nil
	}
}

func (c cronTaskDo) Last() (*model.CronTask, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.CronTask), nil
	}
}

func (c cronTaskDo) Find() ([]*model.CronTask, error) {
	result, err := c.DO.Find()
	return result.([]*model.CronTask), err
}

func (c cronTaskDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CronTask, err error) {
	buf := make([]*model.CronTask, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c cronTaskDo) FindInBatches(result *[]*model.CronTask, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c cronTaskDo) Attrs(attrs ...field.AssignExpr) ICronTaskDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c cronTaskDo) Assign(attrs ...field.AssignExpr) ICronTaskDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c cronTaskDo) Joins(fields ...field.RelationField) ICronTaskDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c cronTaskDo) Preload(fields ...field.RelationField) ICronTaskDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c cronTaskDo) FirstOrInit() (*model.CronTask, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.CronTask), nil
	}
}

func (c cronTaskDo) FirstOrCreate() (*model.CronTask, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.CronTask), nil
	}
}

func (c cronTaskDo) FindByPage(offset int, limit int) (result []*model.CronTask, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c cronTaskDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c cronTaskDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c cronTaskDo) Delete(models ...*model.CronTask) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *cronTaskDo) withDO(do gen.Dao) *cronTaskDo {
	c.DO = *do.(*gen.DO)
	return c
}
